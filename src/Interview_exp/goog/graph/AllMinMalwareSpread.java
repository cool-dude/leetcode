/*LC924: Minimize Malware Spread
https://leetcode.com/problems/minimize-malware-spread/
In a network of nodes, each node i is
directly connected to another node j
if and only if graph[i][j] = 1.
Some nodes initial are initially
infected by malware.  Whenever two
nodes are directly connected and at
least one of those two nodes is infected
by malware, both nodes will be infected
by malware.  This spread of malware
will continue until no more nodes
can be infected in this manner.

We will remove one node from the initial
list.  Return the node that if removed,
would minimize M(initial).  If multiple
nodes could be removed to minimize M(initial),
return such a node with the smallest index.
Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
Output: 0

Example 3:
Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
Output: 1*/
class Sln1{
    int[] p;
    public int minMalwareSpread(int[][] g, int[] initial) {
        int n = g.length;
        p = new int[n];
        for (int i = 0; i < n; i++) p[i] = i;
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (g[i][j] == 1) union(i, j);
        int[] ufSize = new int[n];
        int[] malCount = new int[n];
        for (int i = 0; i < n; i++) ufSize[find(i)]++;
        for (int init : initial) malCount[find(init)]++;
        // for maximum ufSize, if malware count is 1, return that index
        int res = -1;
        int maxSize = 0;
        Arrays.sort(initial);
        for (int init : initial) {
            int idx = find(init);
            if (malCount[idx] == 1 && ufSize[idx] > maxSize) {
                maxSize = ufSize[idx];
                res = init;
            }
        }
        if (maxSize != 0) return res;
        else return initial[0];
    }
    void union(int i, int j) {
        p[find(i)] = find(j);
    }
    int find(int i) {
        if (p[i] == i) return i;
        else {
            p[i] = find(p[i]);
            return p[i];
        }
    }
}
/*LC928: Minimize Malware Spread II
https://leetcode.com/problems/minimize-malware-spread-ii/
(This problem is the same as Minimize
Malware Spread, with the differences bolded.)
In a network of nodes, each node i is directly
connected to another node j if and only if graph[i][j] = 1.
Some nodes initial are initially infected by malware.
Whenever two nodes are directly connected and
at least one of those two nodes is infected
by malware, both nodes will be infected by
malware.  This spread of malware will continue
until no more nodes can be infected in this manner.
Suppose M(initial) is the final number of nodes
infected with malware in the entire network,
after the spread of malware stops.
We will remove one node from the initial
list, completely removing it and any
connections from this node to any other node.
Return the node that if removed, would minimize
M(initial).  If multiple nodes could be
removed to minimize M(initial), return such a node with the smallest index.
Example 1:
Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
Output: 0

Example 2:
Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
Output: 1

Example 3:
Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
Output: 1
Note:
1 < graph.length = graph[0].length <= 300
0 <= graph[i][j] == graph[j][i] <= 1
graph[i][i] = 1
1 <= initial.length < graph.length
0 <= initial[i] < graph.length*/
class Sln2 {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        Set<Integer> mal = new HashSet<>();
        for(int n : initial) {
            mal.add(n);
        }
        int max = -1, ret = -1;
        for(int n : initial){
            int save = 0;
            Set<Integer> visited = new HashSet<>();
            visited.add(n);
            for(int i = 0; i<graph.length; i++){
                if(i != n && graph[n][i] == 1){
                    int temp = dfs(i, visited, mal, graph);
                    if(temp < 0) continue; // encountered malware during exploration, meaning this whole branch doesn't count/contribute
                    save += temp;
                }
            }
            if(save > max){
                ret = n;
                max = save;
            }
        }
        return ret;
    }
    int dfs(int n, Set<Integer> visited, Set<Integer> mal, int[][] graph){
        if(visited.contains(n)) return 0;
        if(mal.contains(n)) return -1;
        visited.add(n);
        int ret = 1; // current node saved (at least for now)
        for(int i = 0; i<graph.length; i++){
            if(i != n && graph[n][i] == 1){
                int temp = dfs(i, visited, mal, graph);
                if(temp == -1) {
                    mal.add(n); // has neighbor malware, marked as malware as well
                    return -1; // return -1, indicating there's malware downstream in this branch, whole branch unqualified!
                }
                ret += temp;
            }
        }
        return ret;
    }
}